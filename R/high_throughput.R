# Tools for high throughput modeling.
#
# The general idea:
#
# Arguments:
# a matrix of training numeric data (x_train),
# a matrix of test numeric data (x_test),
# a matrix with the numeric response (y),
# arguments passed to a pre-processing function,
# arguments passed to a tuning/training tool,
# prediction type
#
# Value:
# a matrix or matrices with predictions,
# pre-processing stats,
# tuning and evaluation stats.

# Modeling tools -------

#' High-throughput regularized linear modeling.
#'
#' @description
#' Functions for light-weight, high-throughput modeling of multiple responses
#' with common large set of explanatory data.
#'
#' @details
#' The `fitHT()` functions bundle pre-processing (modeling
#' variable selection, batch-adjustment), tuning and training (choice of
#' \eqn{\lambda}), model evaluation, and predictions.
#' Technically, the pre-processing step is accomplished by the
#' \code{\link{pre_process}} function and is skipped when the user provides
#' already pre-processed data as an \code{\link{modData}} object.
#' For the tuning, training and evaluation steps, the function
#' \code{\link{train.default}} is employed.
#' Finally, predictions in a format requested by the user and specified by the
#' `type` argument, are generated by the \code{\link{predict.modTrain}} method.
#' The tools will run in parallel, is a furrr-compatible backend is declared,
#' e.g. with \code{\link[future]{plan}}.
#'
#' @return an instance of the `modHT` class with the following components:
#'
#' * `predictions`: model predictions for the test data as a matrix or a list
#' of matrices.
#'
#' * `preprocess_stats`: information of modeling variables after
#' the pre-processing step, like variable name, median and mean value,
#' Gini index.
#'
#' * `model_stats`: metrics of the regularized linear models, such as loss
#' function used for \eqn{\lambda} tuning, \eqn{R^2}, correlations of the
#' observed and predicted modeling response in the training data (regression
#' models), as well as overall accuracy and Cohen's \eqn{\kappa} for comparison
#' of the observed and predicted class assignment (classification models).
#'
#' * `preprocess_globals`: pre-processing parameters specified by the user like
#' modeling variable selection cutoffs or the function used to transform the
#' explanatory variables.
#'
#' * `model_globals`: modeling parameters specified by the user such as modeling
#' family, the function used to transform the response variables, loss function,
#' mixing parameter alpha.
#'
#' * `prediction_globals`: parameters of predictions such as prediction type.
#'
#' * `errors`: an optional vector of error messages.
#'
#' Note the methods \code{\link{nobs.modHT}}, \code{\link{components.modHT}},
#' \code{\link{summary.modHT}}, and \code{\link{plot.modHT}} defined
#' for the class.
#'
#' @references
#' Leek JT, Johnson WE, Parker HS, Jaffe AE, Storey JD. The sva package for
#' removing batch effects and other unwanted variation in high-throughput
#' experiments. Bioinformatics (2012) 28:882. doi:10.1093/BIOINFORMATICS/BTS034
#'
#' @references
#' Friedman J, Hastie T, Tibshirani R. Regularization paths for generalized
#' linear models via coordinate descent.
#' J Stat Softw (2010) 33:1â€“22. doi:10.18637/jss.v033.i01
#'
#' @param x_train a numeric matrix with training explanatory variables.
#' Features are coded by rows, observations are provided in columns.
#'
#' @param x_test a numeric matrix with test explanatory variables.
#' Features are coded by rows, observations are provided in columns.
#'
#' @param x an object of the `modData` class created e.g. with the
#' \code{\link{pre_process}} function.
#'
#' @param y a numeric or factor matrix with the observed responses
#' (e.g. phenotype in the training data). The responses are provided as columns,
#' the observations are given in rows. The row names of `y` must match column
#' name of `x`.
#'
#' @param trans_fun a numeric function to transform responses for modeling.
#' A normality-improving transformation such as `log` may be provided here.
#' Used only for Gaussian family models and ignored elsewhere.
#'
#' @param standardize logical, should `x` values be standardized prior
#' to modeling?
#'
#' @param alpha numeric mixing parameter, which defines the modeling algorithm
#' (RIDGE regression: `alpha = 0`, LASSO: `alpha = 1`, Elastic Net otherwise).
#' See \code{\link[glmnet]{glmnet}} for details.
#'
#' @param family family of the `glmnet` models. Currently, only 'gaussian',
#' 'binomial', 'poisson', and 'multinomial' are implemented.
#' See: \code{\link[glmnet]{glmnet}} for details.
#'
#' @param type.measure model selection statistic (i.e. loss function). Defaults
#' to deviance. See \code{\link[glmnet]{cv.glmnet}} for details.
#'
#' @param type.predict prediction type. See: \code{\link{predict.modTrain}} for
#' details.
#'
#' @param safe logical, should modeling proceed in spite of errors for
#' some responses? .
#' If `TRUE`, any errors are logged in `errors` element of the output. This
#' option may be, however, considerably slower.
#'
#' @param preprocess.args a named list with arguments passed to
#' \code{\link{pre_process}}, such as variable selection cutoffs. Not available
#' if a `modData` object is used as `x`.
#'
#' @param predict.args a named list with arguments passed to
#' \code{\link{predict.modTrain}}, such as variable offset.
#'
#' @param ... additional arguments passed to \code{\link[glmnet]{cv.glmnet}} and
#' \code{\link[glmnet]{glmnet}}.
#'
#' @export

  fitHT <- function(...) UseMethod('fitHT')

#' @rdname fitHT
#' @export fitHT.default
#' @export

  fitHT.default <- function(x_train,
                            x_test,
                            y,
                            trans_fun = identity,
                            standardize = FALSE,
                            alpha = 1,
                            family = 'gaussian',
                            type.measure = c("default",
                                             "mse",
                                             "deviance",
                                             "class",
                                             "auc",
                                             "mae",
                                             "C"),
                            type.predict = c('link',
                                             'response',
                                             'class'),
                            safe = FALSE,
                            preprocess.args = list(),
                            predict.args = list(), ...) {

    ## input control is done by downstream functions

    message('Pre-processing')

    pre_call <- call2(.fn = 'pre_process',
                      train = x_train,
                      test = x_test,
                      !!!preprocess.args)

    pre_object <- eval(pre_call)

    fitHT.modData(x = pre_object,
                  y = y,
                  trans_fun = trans_fun,
                  standardize = standardize,
                  alpha = alpha,
                  family = family,
                  type.measure = type.measure,
                  type.predict = type.predict,
                  safe = safe,
                  predict.args = predict.args, ...)

  }

#' @rdname fitHT
#' @export fitHT.modData
#' @export

  fitHT.modData <- function(x,
                            y,
                            trans_fun = identity,
                            standardize = FALSE,
                            alpha = 1,
                            family = 'gaussian',
                            type.measure = c("default",
                                             "mse",
                                             "deviance",
                                             "class",
                                             "auc",
                                             "mae",
                                             "C"),
                            type.predict = c('link',
                                             'response',
                                             'class'),
                            safe = FALSE,
                            predict.args = list(), ...) {

    ## input control --------

    ## a minimal variant, detailed controls will be done
    ## be the modeling function

    stopifnot(is_modData(x))

    stopifnot(is.function(trans_fun))
    stopifnot(is.numeric(alpha))

    type.measure <- match.arg(type.measure[1],
                              c("default",
                                "mse",
                                "deviance",
                                "class",
                                "auc",
                                "mae",
                                "C"))

    family <- match.arg(family[1],
                        c('gaussian', 'binomial', 'poisson', 'multinomial'))

    type.predict <- match.arg(type.predict[1],
                              c('link', 'response', 'class'))

    stopifnot(is.logical(safe))

    ## model tuning, training and evaluation --------

    train_results <- train(x = x,
                           y = y,
                           trans_fun = trans_fun,
                           standardize = standardize,
                           alpha = alpha,
                           family = family,
                           type.measure = type.measure,
                           safe = safe, ...)

    if(!is_modTrain(train_results)) {

      warning('Modeling failed. Error messages are returned.', call. = FALSE)

      return(train_results)

    }

    ## model predictions ----------

    pred_call <- call2(.fn = 'predict.modTrain',
                       object = train_results,
                       newdata = x,
                       type = type.predict,
                       !!!predict.args)

    preds <- eval(pred_call)

    ## output ---------

    message('Preparing the output modHT object')

    preprocess_stats <- components(x, 'stats')[[2]]

    model_stats <- summary(train_results)

    preprocess_globals <- components(x, 'limits')

    model_globals <- components(train_results, 'globals')

    prediction_globals <-
      c(list(type = type.predict),
        predict.args)

    modHT(list(predictions = preds,
               preprocess_stats = preprocess_stats,
               model_stats = model_stats,
               preprocess_globals = preprocess_globals,
               model_globals = model_globals,
               prediction_globals = prediction_globals,
               errors = components(train_results, 'errors')))

  }

# END -------
